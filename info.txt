Backend tarafında en az bir RDBMs sonra bir NoSql, search gerekiyor Elasticsearch,
 cache lazım redis/couchbase, messaging için rabbit/kafka, deployment için CI/CD gitlab+argocd…
 Projeyi containerize etmek lazım docker, bu containerlar nerede çalışacak kubernetes, bir de cloud
  kullanılıyorsa yanına bir tane provider. E projeler canlıya çıktı monitor edilmesi lazım, logging için ELK, metrikler için prometheus grafana, APM lazım newrelic. 
 Yetti mi, hayır…
 Servicelere gateway lazım, networking için ingress gateway hatta service mesh Istio.
  E güvenliği bir kenara mı atacağız, secret management için vault, policy için OPA (gatekeeper), authorization lazım IAM, 
 e sistemi test etmek lazım e2e testing load testing contract testing…

Anahtar kelimelerinizi Google Trends, Answer the public, Semrush vb kullanarak çeşitlendirebilirsiniz.

******************************************
Here're a few facts about the querysets:

The QuerySet is immutable - chaining methods to our queryset doesn't modify the original queryset - it creates a new one.
The QuerySet is a generator when you iterate over it for the first time - when you start iterating over the queryset, internally it executes a SELECT query and yields the DB rows shaped into the desired Python data structure.
The QuerySet is an iterable - once we've iterated over the queryset once, the queryset puts the DB result into a cache. On every subsequent iteration, we'll use the cached objects. This prevents us from unwanted queries duplication.
-----------------------------
calls the SQL compiler to execute SELECT query
puts the raw database data (a list of tuples) into ORM objects(.all), dictionaries(.values) or tuples(.values_list) and return it
QUERY PERFORMANCE
----------------------------------------
The SQL query performance is a huge topic and we're not going to get into it. Here're a few common sense things that could make our DB work faster:

query only for the DB column you need - use .only and .defer
query only for the DB rows you need - use .filter and .exclude
use DB indexes.
-----------------------------------------

If we fetch too much data and we need it read-only, .values and .values_list are a better choice than .all.

-------------------------------------
Methods chaining and order of execution
The order of the method chaining is not always the same as the order of execution.
We could categorize the QuerySet methods into 2 categories:

Methods that modify the SQL query - filter/ exclude/ annotate/ only / etc. They are "executed" into the database when it runs the SQL query.
Methods that define the data structure - all/ values / values_list/etc. They're executed in our Django app (by iterating over the iterable class and modifying the data)
The ORM allows us to chain the same methods in almost any order. But, no matter the order of chaining, the order of execution will always be:

Execute the methods that are modifying the SQL query
Run the query in the database
Execute the methods that define the data structure

----------------------------------------------------------------------

Django ORM's QuerySet methods that cover each of the CRUD operations are:

Create(INSERT) - QuerySet.create
Read(SELECT) - QuerySet.__iter__
Update - QuerySet.update
Delete - QuerySet.delete

There are a lot of Python profilers you can choose from (like cProfile or line_profiler), and also some other tools you may want to leverage later on for visualising the results (like SnakeViz or KCachegrind).

You can also find profilers strictly directed to Django(like Silk to store and analyze database queries).
-----------------------------------



